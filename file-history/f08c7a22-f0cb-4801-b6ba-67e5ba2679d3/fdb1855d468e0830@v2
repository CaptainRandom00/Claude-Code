/**
 * @fileoverview Simplified Product Profile Edit Modal Component
 * @description Working version that matches our actual API and database schema
 */

import React, { useState, useEffect } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from "@/components/ui/form";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import {
  Save,
  X,
  RefreshCw,
  AlertTriangle,
  CheckCircle2,
  AlertCircle
} from 'lucide-react';
import { useToast } from "@/components/ui/use-toast";
import { ProductImageManager } from './ProductImageManager';

// Form validation schema for our actual fields
const editProductSchema = z.object({
  description: z.string().min(1, 'Description is required').max(255, 'Description too long'),
  supplier: z.string().min(1, 'Supplier is required').max(100, 'Supplier name too long'),
  category: z.string().min(1, 'Category is required').max(100, 'Category name too long'),
  packingSize: z.string().max(100, 'Packing size too long').optional().or(z.literal('')),
  unitsPerCase: z.number().int().min(1, 'Must be at least 1').max(999999, 'Value too large').nullable(),
  unitType: z.string().max(50, 'Unit type too long').optional().or(z.literal('')),
  caseQuantity: z.number().int().min(1, 'Must be at least 1').max(999999, 'Value too large'),
  caseUnitDescription: z.string().max(100, 'Case unit description too long').optional().or(z.literal('')),
  caseSource: z.string().max(50, 'Case source too long').optional().or(z.literal('')),
  isActive: z.boolean(),
  changeReason: z.string().min(1, 'Change reason is required').max(255, 'Reason too long')
});

type EditProductFormData = z.infer<typeof editProductSchema>;

interface EditProductPopupProps {
  itemCode: string | null;
  isOpen: boolean;
  onClose: () => void;
  onSaved?: (profile: any) => void;
}

// Common suppliers and categories for dropdowns
const SUPPLIERS = [
  'SIAM', 'WFL', 'QIN002', 'INTERLIN', 'PARFETTS', 'BOOKER', 'BESTWAY', 'NISA', 'COSTCO'
];

const CATEGORIES = [
  'CANS, PACKETS & JARS',
  'FROZEN READY MEALS',
  'DRINKS',
  'FRESH',
  'CONFECTIONERY',
  'HOUSEHOLD',
  'HEALTH & BEAUTY',
  'TOBACCO',
  'ALCOHOL'
];

export function EditProductPopup({ itemCode, isOpen, onClose, onSaved }: EditProductPopupProps) {
  const [isWorking, setIsWorking] = useState(false);
  const queryClient = useQueryClient();
  const { toast } = useToast();

  const form = useForm<EditProductFormData>({
    resolver: zodResolver(editProductSchema),
    defaultValues: {
      description: '',
      supplier: '',
      category: '',
      packingSize: '',
      unitsPerCase: null,
      unitType: '',
      caseQuantity: 1,
      caseUnitDescription: '',
      caseSource: '',
      isActive: true,
      changeReason: ''
    }
  });

  // Fetch product data for editing
  const { data: editData, isLoading, error, refetch } = useQuery({
    queryKey: ['product-profile-edit', itemCode],
    queryFn: async () => {
      if (!itemCode) throw new Error('No item code provided');

      const response = await fetch(`/api/product-profiles/${itemCode}/edit?includeHistory=true&historyLimit=5`);
      if (!response.ok) {
        throw new Error(`Failed to fetch product data: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('Edit data received:', result);
      return result;
    },
    enabled: !!itemCode && isOpen,
    staleTime: 30000, // 30 seconds
    gcTime: 300000, // 5 minutes
    retry: 3,
    retryDelay: 1000,
    onError: (err) => {
      console.error('Failed to fetch edit data:', err);
    }
  });

  // Get actual product data
  const { data: productData } = useQuery({
    queryKey: ['product-profile', itemCode],
    queryFn: async () => {
      if (!itemCode) throw new Error('No item code provided');

      const response = await fetch(`/api/product-profiles?search=${itemCode}&limit=1`);
      if (!response.ok) {
        throw new Error(`Failed to fetch product: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('Product data received:', result);

      if (result.data && result.data.length > 0) {
        return result.data[0];
      }
      throw new Error('Product not found');
    },
    enabled: !!itemCode && isOpen,
    staleTime: 30000,
    gcTime: 300000,
  });

  // Update mutation
  const updateMutation = useMutation({
    mutationFn: async (formData: EditProductFormData) => {
      if (!itemCode) throw new Error('No item code provided');

      const { changeReason, ...updates } = formData;

      const response = await fetch(`/api/product-profiles/${itemCode}/edit`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          updates,
          changeReason
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update product');
      }

      return response.json();
    },
    onSuccess: (data) => {
      toast({
        title: "Product Updated",
        description: `Successfully updated ${itemCode}`,
      });

      // Invalidate related queries
      queryClient.invalidateQueries({ queryKey: ['product-profiles'] });
      queryClient.invalidateQueries({ queryKey: ['product-profile-edit', itemCode] });

      onSaved?.(data.profile);
      onClose();
    },
    onError: (error) => {
      console.error('Update failed:', error);
      toast({
        title: "Update Failed",
        description: error.message || 'Failed to update product',
        variant: "destructive",
      });
    },
  });

  // Populate form when product data loads
  useEffect(() => {
    if (productData) {
      console.log('Populating form with product data:', productData);
      form.reset({
        description: productData.description || '',
        supplier: productData.supplier || '',
        category: productData.category || '',
        packingSize: productData.packingSize || '',
        unitsPerCase: productData.unitsPerCase,
        unitType: productData.unitType || '',
        caseQuantity: productData.caseQuantity || 1,
        caseUnitDescription: productData.caseUnitDescription || '',
        caseSource: productData.caseSource || '',
        isActive: productData.isActive ?? true,
        changeReason: ''
      });
    }
  }, [productData, form]);

  const handleSubmit = (formData: EditProductFormData) => {
    console.log('Submitting form data:', formData);
    updateMutation.mutate(formData);
  };

  if (!isOpen) return null;

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            Edit Product Profile
            {itemCode && (
              <Badge variant="outline" className="font-mono">
                {itemCode}
              </Badge>
            )}
          </DialogTitle>
          <DialogDescription>
            Modify product details. All changes are tracked for audit purposes.
          </DialogDescription>
        </DialogHeader>

        {isLoading && (
          <div className="flex items-center justify-center py-8">
            <RefreshCw className="h-6 w-6 animate-spin mr-2" />
            Loading product data...
          </div>
        )}

        {error && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertDescription>
              Failed to load product data: {error.message}
              <Button
                variant="outline"
                size="sm"
                onClick={() => refetch()}
                className="ml-2"
              >
                Retry
              </Button>
            </AlertDescription>
          </Alert>
        )}

        {editData && productData && (
          <div className="space-y-6">
            <Alert>
              <CheckCircle2 className="h-4 w-4" />
              <AlertDescription>
                Edit session established. You can now modify the product details below.
              </AlertDescription>
            </Alert>

            <Form {...form}>
              <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-6">
                {/* Basic Information */}
                <Card>
                  <CardHeader>
                    <CardTitle className="text-sm">Basic Information</CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <FormField
                      control={form.control}
                      name="description"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Description *</FormLabel>
                          <FormControl>
                            <Input placeholder="Product description" {...field} />
                          </FormControl>
                          <FormMessage />
                        </FormItem>
                      )}
                    />

                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      <FormField
                        control={form.control}
                        name="supplier"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Supplier *</FormLabel>
                            <Select onValueChange={field.onChange} value={field.value}>
                              <FormControl>
                                <SelectTrigger>
                                  <SelectValue placeholder="Select supplier" />
                                </SelectTrigger>
                              </FormControl>
                              <SelectContent>
                                {SUPPLIERS.map((supplier) => (
                                  <SelectItem key={supplier} value={supplier}>
                                    {supplier}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="category"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Category *</FormLabel>
                            <Select onValueChange={field.onChange} value={field.value}>
                              <FormControl>
                                <SelectTrigger>
                                  <SelectValue placeholder="Select category" />
                                </SelectTrigger>
                              </FormControl>
                              <SelectContent>
                                {CATEGORIES.map((category) => (
                                  <SelectItem key={category} value={category}>
                                    {category}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>
                  </CardContent>
                </Card>

                {/* Packaging Information */}
                <Card>
                  <CardHeader>
                    <CardTitle className="text-sm">Packaging & Units</CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <FormField
                        control={form.control}
                        name="packingSize"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Packing Size</FormLabel>
                            <FormControl>
                              <Input placeholder="e.g., 12x500ml" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="unitsPerCase"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Units Per Case</FormLabel>
                            <FormControl>
                              <Input
                                type="number"
                                placeholder="24"
                                {...field}
                                value={field.value || ''}
                                onChange={(e) => field.onChange(e.target.value ? parseInt(e.target.value) : null)}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="unitType"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Unit Type</FormLabel>
                            <FormControl>
                              <Input placeholder="Each, Kg, Litre" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>

                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                      <FormField
                        control={form.control}
                        name="caseQuantity"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Case Quantity *</FormLabel>
                            <FormControl>
                              <Input
                                type="number"
                                placeholder="1"
                                {...field}
                                onChange={(e) => field.onChange(parseInt(e.target.value) || 1)}
                              />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="caseUnitDescription"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Case Unit Description</FormLabel>
                            <FormControl>
                              <Input placeholder="Case description" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />

                      <FormField
                        control={form.control}
                        name="caseSource"
                        render={({ field }) => (
                          <FormItem>
                            <FormLabel>Case Source</FormLabel>
                            <FormControl>
                              <Input placeholder="Source info" {...field} />
                            </FormControl>
                            <FormMessage />
                          </FormItem>
                        )}
                      />
                    </div>
                  </CardContent>
                </Card>

                {/* Product Images */}
                {itemCode && (
                  <ProductImageManager
                    itemCode={itemCode}
                    images={productData?.imageMetadata || []}
                    imageCount={productData?.imageCount || 0}
                    onUpdate={() => {
                      // Refetch product data when images are updated
                      queryClient.invalidateQueries({ queryKey: ['product-profile', itemCode] });
                      queryClient.invalidateQueries({ queryKey: ['product-profiles'] });
                    }}
                  />
                )}

                {/* Status and Change Reason */}
                <Card>
                  <CardHeader>
                    <CardTitle className="text-sm">Status & Change Tracking</CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-4">
                    <FormField
                      control={form.control}
                      name="isActive"
                      render={({ field }) => (
                        <FormItem className="flex flex-row items-center justify-between rounded-lg border p-3 shadow-sm">
                          <div className="space-y-0.5">
                            <FormLabel>Active Status</FormLabel>
                            <div className="text-xs text-muted-foreground">
                              Enable/disable this product
                            </div>
                          </div>
                          <FormControl>
                            <input
                              type="checkbox"
                              checked={field.value}
                              onChange={field.onChange}
                              className="h-4 w-4"
                            />
                          </FormControl>
                        </FormItem>
                      )}
                    />

                    <FormField
                      control={form.control}
                      name="changeReason"
                      render={({ field }) => (
                        <FormItem>
                          <FormLabel>Change Reason *</FormLabel>
                          <FormControl>
                            <Input
                              placeholder="Reason for these changes..."
                              {...field}
                            />
                          </FormControl>
                          <div className="text-xs text-muted-foreground">
                            Briefly explain why you're making these changes
                          </div>
                          <FormMessage />
                        </FormItem>
                      )}
                    />
                  </CardContent>
                </Card>
              </form>
            </Form>
          </div>
        )}

        <DialogFooter className="flex items-center gap-2">
          <Button
            variant="outline"
            onClick={onClose}
            disabled={updateMutation.isPending}
          >
            <X className="h-4 w-4 mr-2" />
            Cancel
          </Button>

          <Button
            onClick={form.handleSubmit(handleSubmit)}
            disabled={updateMutation.isPending || !editData || !productData}
            className="flex items-center gap-2"
          >
            {updateMutation.isPending ? (
              <RefreshCw className="h-4 w-4 animate-spin" />
            ) : (
              <Save className="h-4 w-4" />
            )}
            {updateMutation.isPending ? 'Saving...' : 'Save Changes'}
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}

export default EditProductPopup;