/**
 * Calculation Engine Unit Tests
 * Feature: 028-build-a-widget
 *
 * Tests for client-side calculation utilities including
 * filters, grouping, aggregations, comparisons, and formatting.
 */

import { describe, it, expect } from 'vitest';
import {
  applyFilters,
  applyGroupBy,
  applyAggregations,
  applyComparisons,
  applySort,
  applyCalculationPipeline,
  formatValue,
  getTrendIndicator,
} from '../../client/src/lib/calculation-engine';
import type { CalculationFilter, Aggregation, Comparison } from '../../client/src/types/widget-types';

describe('Calculation Engine', () => {
  describe('applyFilters', () => {
    const testData = [
      { id: 1, name: 'Product A', price: 100, category: 'electronics' },
      { id: 2, name: 'Product B', price: 200, category: 'electronics' },
      { id: 3, name: 'Product C', price: 150, category: 'furniture' },
      { id: 4, name: 'Product D', price: 50, category: 'furniture' },
    ];

    it('should return all data when no filters provided', () => {
      const result = applyFilters(testData, []);
      expect(result).toHaveLength(4);
    });

    it('should filter with eq (equals) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'category', operator: 'eq', value: 'electronics' },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.every((item) => item.category === 'electronics')).toBe(true);
    });

    it('should filter with ne (not equals) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'category', operator: 'ne', value: 'electronics' },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.every((item) => item.category === 'furniture')).toBe(true);
    });

    it('should filter with gt (greater than) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'price', operator: 'gt', value: 100 },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.every((item) => item.price > 100)).toBe(true);
    });

    it('should filter with lt (less than) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'price', operator: 'lt', value: 150 },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.every((item) => item.price < 150)).toBe(true);
    });

    it('should filter with gte (greater than or equal) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'price', operator: 'gte', value: 150 },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.every((item) => item.price >= 150)).toBe(true);
    });

    it('should filter with lte (less than or equal) operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'price', operator: 'lte', value: 150 },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(3);
      expect(result.every((item) => item.price <= 150)).toBe(true);
    });

    it('should filter with in operator', () => {
      const filters: CalculationFilter[] = [
        { field: 'id', operator: 'in', value: [1, 3] },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(2);
      expect(result.map((item) => item.id)).toEqual([1, 3]);
    });

    it('should filter with contains operator (case-insensitive)', () => {
      const filters: CalculationFilter[] = [
        { field: 'name', operator: 'contains', value: 'product' },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(4);
    });

    it('should apply multiple filters (AND logic)', () => {
      const filters: CalculationFilter[] = [
        { field: 'category', operator: 'eq', value: 'electronics' },
        { field: 'price', operator: 'gt', value: 100 },
      ];

      const result = applyFilters(testData, filters);

      expect(result).toHaveLength(1);
      expect(result[0].id).toBe(2);
    });
  });

  describe('applyGroupBy', () => {
    const testData = [
      { category: 'A', subcategory: 'X', amount: 100 },
      { category: 'A', subcategory: 'Y', amount: 200 },
      { category: 'B', subcategory: 'X', amount: 300 },
      { category: 'B', subcategory: 'Y', amount: 400 },
    ];

    it('should return all data in single group when no groupBy provided', () => {
      const result = applyGroupBy(testData, []);

      expect(result).toHaveProperty('all');
      expect(result.all).toHaveLength(4);
    });

    it('should group by single field', () => {
      const result = applyGroupBy(testData, ['category']);

      expect(Object.keys(result)).toHaveLength(2);
      expect(result).toHaveProperty('A');
      expect(result).toHaveProperty('B');
      expect(result['A']).toHaveLength(2);
      expect(result['B']).toHaveLength(2);
    });

    it('should group by multiple fields', () => {
      const result = applyGroupBy(testData, ['category', 'subcategory']);

      expect(Object.keys(result)).toHaveLength(4);
      expect(result).toHaveProperty('A|X');
      expect(result).toHaveProperty('A|Y');
      expect(result).toHaveProperty('B|X');
      expect(result).toHaveProperty('B|Y');
    });
  });

  describe('applyAggregations', () => {
    const testData = [
      { amount: 100, quantity: 5 },
      { amount: 200, quantity: 10 },
      { amount: 300, quantity: 15 },
    ];

    it('should calculate sum aggregation', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'sum' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result).toHaveLength(1);
      expect(result[0].amount).toBe(600);
    });

    it('should calculate average aggregation', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'average' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0].amount).toBe(200);
    });

    it('should calculate count aggregation', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'count' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0].amount).toBe(3);
    });

    it('should calculate min aggregation', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'min' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0].amount).toBe(100);
    });

    it('should calculate max aggregation', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'max' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0].amount).toBe(300);
    });

    it('should use alias for aggregation field name', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'sum', alias: 'totalAmount' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0]).toHaveProperty('totalAmount');
      expect(result[0].totalAmount).toBe(600);
    });

    it('should calculate multiple aggregations', () => {
      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'sum' },
        { field: 'quantity', type: 'average' },
      ];

      const result = applyAggregations(testData, aggregations);

      expect(result[0].amount).toBe(600);
      expect(result[0].quantity).toBe(10);
    });

    it('should aggregate grouped data', () => {
      const groupedData = {
        'A': [{ amount: 100 }, { amount: 200 }],
        'B': [{ amount: 300 }],
      };

      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'sum' },
      ];

      const result = applyAggregations(groupedData, aggregations, ['category']);

      expect(result).toHaveLength(2);
      expect(result.find((r) => r.category === 'A')?.amount).toBe(300);
      expect(result.find((r) => r.category === 'B')?.amount).toBe(300);
    });

    it('should filter out null and undefined values', () => {
      const dataWithNulls = [
        { amount: 100 },
        { amount: null },
        { amount: 200 },
        { amount: undefined },
      ];

      const aggregations: Aggregation[] = [
        { field: 'amount', type: 'sum' },
      ];

      const result = applyAggregations(dataWithNulls, aggregations);

      expect(result[0].amount).toBe(300);
    });
  });

  describe('applyComparisons', () => {
    it('should calculate percent change', () => {
      const data = [
        { current: 150, previous: 100 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'percent_change',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_percent_change).toBe(50);
    });

    it('should calculate difference', () => {
      const data = [
        { current: 150, previous: 100 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'difference',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_difference).toBe(50);
    });

    it('should calculate ratio', () => {
      const data = [
        { current: 200, previous: 100 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'ratio',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_ratio).toBe(2);
    });

    it('should handle division by zero in percent change', () => {
      const data = [
        { current: 100, previous: 0 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'percent_change',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_percent_change).toBe(0);
    });

    it('should handle division by zero in ratio', () => {
      const data = [
        { current: 100, previous: 0 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'ratio',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_ratio).toBe(0);
    });

    it('should calculate negative percent change', () => {
      const data = [
        { current: 80, previous: 100 },
      ];

      const comparisons: Comparison[] = [
        {
          type: 'percent_change',
          currentField: 'current',
          comparisonField: 'previous',
        },
      ];

      const result = applyComparisons(data, comparisons);

      expect(result[0].current_percent_change).toBe(-20);
    });
  });

  describe('applySort', () => {
    const testData = [
      { name: 'C', value: 30 },
      { name: 'A', value: 10 },
      { name: 'B', value: 20 },
    ];

    it('should sort ascending by single field', () => {
      const sortConfig = [{ field: 'name', order: 'asc' as const }];
      const result = applySort(testData, sortConfig);

      expect(result[0].name).toBe('A');
      expect(result[1].name).toBe('B');
      expect(result[2].name).toBe('C');
    });

    it('should sort descending by single field', () => {
      const sortConfig = [{ field: 'value', order: 'desc' as const }];
      const result = applySort(testData, sortConfig);

      expect(result[0].value).toBe(30);
      expect(result[1].value).toBe(20);
      expect(result[2].value).toBe(10);
    });

    it('should handle multi-field sort', () => {
      const complexData = [
        { category: 'A', value: 20 },
        { category: 'B', value: 10 },
        { category: 'A', value: 10 },
      ];

      const sortConfig = [
        { field: 'category', order: 'asc' as const },
        { field: 'value', order: 'desc' as const },
      ];

      const result = applySort(complexData, sortConfig);

      expect(result[0]).toEqual({ category: 'A', value: 20 });
      expect(result[1]).toEqual({ category: 'A', value: 10 });
      expect(result[2]).toEqual({ category: 'B', value: 10 });
    });

    it('should return original data when no sort config provided', () => {
      const result = applySort(testData, []);
      expect(result).toEqual(testData);
    });
  });

  describe('applyCalculationPipeline', () => {
    const testData = [
      { category: 'A', status: 'active', amount: 100 },
      { category: 'A', status: 'inactive', amount: 200 },
      { category: 'B', status: 'active', amount: 300 },
      { category: 'B', status: 'active', amount: 400 },
    ];

    it('should execute complete pipeline: filter → group → aggregate → sort', () => {
      const config = {
        filters: [
          { field: 'status', operator: 'eq' as const, value: 'active' },
        ],
        groupBy: ['category'],
        aggregations: [
          { field: 'amount', type: 'sum' as const },
        ],
        sort: [
          { field: 'amount', order: 'desc' as const },
        ],
        comparisons: [],
        limit: 0,
      };

      const result = applyCalculationPipeline(testData, config);

      expect(result).toHaveLength(2);
      expect(result[0].category).toBe('B');
      expect(result[0].amount).toBe(700);
      expect(result[1].category).toBe('A');
      expect(result[1].amount).toBe(100);
    });

    it('should apply limit to results', () => {
      const config = {
        filters: [],
        groupBy: ['category'],
        aggregations: [
          { field: 'amount', type: 'sum' as const },
        ],
        sort: [],
        comparisons: [],
        limit: 1,
      };

      const result = applyCalculationPipeline(testData, config);

      expect(result).toHaveLength(1);
    });

    it('should handle pipeline without grouping', () => {
      const config = {
        filters: [
          { field: 'status', operator: 'eq' as const, value: 'active' },
        ],
        groupBy: [],
        aggregations: [
          { field: 'amount', type: 'sum' as const },
        ],
        sort: [],
        comparisons: [],
        limit: 0,
      };

      const result = applyCalculationPipeline(testData, config);

      expect(result).toHaveLength(1);
      expect(result[0].amount).toBe(800);
    });

    it('should apply comparisons in pipeline', () => {
      const dataWithComparison = [
        { current: 150, previous: 100 },
      ];

      const config = {
        filters: [],
        groupBy: [],
        aggregations: [
          { field: 'current', type: 'sum' as const },
          { field: 'previous', type: 'sum' as const },
        ],
        sort: [],
        comparisons: [
          {
            type: 'percent_change' as const,
            currentField: 'current',
            comparisonField: 'previous',
          },
        ],
        limit: 0,
      };

      const result = applyCalculationPipeline(dataWithComparison, config);

      expect(result[0]).toHaveProperty('current_percent_change');
      expect(result[0].current_percent_change).toBe(50);
    });
  });

  describe('formatValue', () => {
    it('should format currency values', () => {
      const result = formatValue(1234.56, 'currency', 2);
      expect(result).toBe('$1,234.56');
    });

    it('should format percentage values', () => {
      const result = formatValue(45.678, 'percentage', 2);
      expect(result).toBe('45.68%');
    });

    it('should format number values', () => {
      const result = formatValue(1234567.89, 'number', 2);
      expect(result).toContain('1,234,567.89');
    });

    it('should handle null values', () => {
      const result = formatValue(null, 'currency');
      expect(result).toBe('-');
    });

    it('should handle undefined values', () => {
      const result = formatValue(undefined, 'number');
      expect(result).toBe('-');
    });

    it('should handle NaN values', () => {
      const result = formatValue(NaN, 'percentage');
      expect(result).toBe('-');
    });

    it('should respect decimal places', () => {
      const result = formatValue(123.456789, 'number', 3);
      expect(result).toContain('123.457');
    });

    it('should use default format when no format specified', () => {
      const result = formatValue(123.456);
      expect(result).toBe('123.46');
    });
  });

  describe('getTrendIndicator', () => {
    it('should return up trend for positive values', () => {
      const result = getTrendIndicator(25);

      expect(result.direction).toBe('up');
      expect(result.color).toBe('text-green-500');
      expect(result.icon).toBe('↑');
    });

    it('should return down trend for negative values', () => {
      const result = getTrendIndicator(-15);

      expect(result.direction).toBe('down');
      expect(result.color).toBe('text-red-500');
      expect(result.icon).toBe('↓');
    });

    it('should return neutral trend for zero', () => {
      const result = getTrendIndicator(0);

      expect(result.direction).toBe('neutral');
      expect(result.color).toBe('text-gray-500');
      expect(result.icon).toBe('→');
    });

    it('should handle small positive values', () => {
      const result = getTrendIndicator(0.01);

      expect(result.direction).toBe('up');
    });

    it('should handle small negative values', () => {
      const result = getTrendIndicator(-0.01);

      expect(result.direction).toBe('down');
    });
  });

  describe('Performance', () => {
    it('should handle large datasets (10K+ records)', () => {
      const largeDataset = Array.from({ length: 10000 }, (_, i) => ({
        id: i + 1,
        category: `Category ${i % 10}`,
        value: Math.random() * 1000,
      }));

      const config = {
        filters: [
          { field: 'value', operator: 'gt' as const, value: 500 },
        ],
        groupBy: ['category'],
        aggregations: [
          { field: 'value', type: 'sum' as const },
          { field: 'id', type: 'count' as const },
        ],
        sort: [
          { field: 'value', order: 'desc' as const },
        ],
        comparisons: [],
        limit: 10,
      };

      const startTime = Date.now();
      const result = applyCalculationPipeline(largeDataset, config);
      const duration = Date.now() - startTime;

      expect(result).toHaveLength(10);
      expect(duration).toBeLessThan(1000); // Should complete within 1 second
    });
  });
});
