/**
 * Dashboard Viewer Page
 * Feature: 028-build-a-widget
 *
 * Main dashboard page for viewing pre-configured dashboards with live widgets
 * Implements responsive grid layout with react-grid-layout (per spec.md FR-021)
 */

import React, { useEffect, useState } from 'react';
import { useRoute } from 'wouter';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { Responsive, WidthProvider, Layout } from 'react-grid-layout';
import { WidgetContainer } from '@/components/widgets/base/WidgetContainer';
import { WidgetFactory } from '@/components/widgets/WidgetFactory';
import { useWidgetData } from '@/hooks/useWidgetData';
import { BREAKPOINTS, COLUMNS } from '@/types/widget-types';
import type { WidgetDefinition, DashboardWidget } from '@/types/widget-types';
import { getWidgetSizeConfig } from '@/constants/widget-size-config';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import {
  Sheet,
  SheetContent,
  SheetDescription,
  SheetHeader,
  SheetTitle,
  SheetTrigger,
} from '@/components/ui/sheet';
import { Save, Filter, Loader2, CheckCircle, Edit3, X } from 'lucide-react';

const ResponsiveGridLayout = WidthProvider(Responsive);

interface Dashboard {
  id: number;
  name: string;
  description: string | null;
  widgets: DashboardWidget[];
}

/**
 * Fetch dashboard data with widgets
 */
async function fetchDashboard(id: number): Promise<Dashboard> {
  const response = await fetch(`/api/widgets/dashboards/${id}`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error || 'Failed to fetch dashboard');
  }

  return response.json();
}

/**
 * Individual widget component with data fetching
 */
function Widget({ widget }: { widget: DashboardWidget }) {
  const {
    data,
    lastFetched,
    isLoading,
    isError,
    error,
    refetch,
  } = useWidgetData({
    widgetDefinition: widget.widgetDefinition as WidgetDefinition,
  });

  return (
    <WidgetContainer
      widgetId={widget.id}
      title={widget.widgetDefinition.name}
      loading={isLoading}
      error={error}
      lastFetched={lastFetched}
      onRefresh={() => refetch()}
    >
      <WidgetFactory
        widgetType={widget.widgetDefinition.widgetType}
        data={data}
        visualizationConfig={widget.widgetDefinition.visualizationConfig}
      />
    </WidgetContainer>
  );
}

/**
 * Main Dashboard Viewer Component
 */
export default function DashboardViewer() {
  const [match, params] = useRoute('/dashboards/:id');
  const dashboardId = params?.id ? parseInt(params.id) : 1; // Default to dashboard 1
  const queryClient = useQueryClient();

  // State for save dialog and filters
  const [showSaveDialog, setShowSaveDialog] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  const [dashboardName, setDashboardName] = useState('');
  const [dateRangeStart, setDateRangeStart] = useState('');
  const [dateRangeEnd, setDateRangeEnd] = useState('');
  const [showSuccessMessage, setShowSuccessMessage] = useState(false);

  // User Story 4: Layout customization state
  const [editMode, setEditMode] = useState(false);
  const [layoutsModified, setLayoutsModified] = useState(false);

  // Fetch dashboard configuration
  const {
    data: dashboard,
    isLoading: isDashboardLoading,
    isError: isDashboardError,
    error: dashboardError,
  } = useQuery({
    queryKey: ['dashboard', dashboardId],
    queryFn: () => fetchDashboard(dashboardId),
  });

  // Update dashboard mutation
  const updateDashboard = useMutation({
    mutationFn: async (data: { name?: string; globalFilters?: any }) => {
      const response = await fetch(`/api/widgets/dashboards/${dashboardId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      if (!response.ok) throw new Error('Failed to update dashboard');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['dashboard', dashboardId] });
      setShowSaveDialog(false);
      setShowSuccessMessage(true);
      setTimeout(() => setShowSuccessMessage(false), 3000);
    },
  });

  // User Story 4: Save layout mutation
  const saveLayout = useMutation({
    mutationFn: async (layoutsToSave: { [key: string]: Layout[] }) => {
      // Convert layouts to widget_layouts format
      const widgetLayouts = dashboard!.widgets.flatMap((widget) => {
        return Object.entries(layoutsToSave).map(([breakpoint, layouts]) => {
          const layout = layouts.find((l) => l.i === widget.id.toString());
          if (!layout) return null;

          return {
            dashboardWidgetId: widget.id,
            breakpoint,
            x: layout.x,
            y: layout.y,
            w: layout.w,
            h: layout.h,
            minW: layout.minW || null,
            minH: layout.minH || null,
            maxW: layout.maxW || null,
            maxH: layout.maxH || null,
          };
        }).filter(Boolean);
      });

      const response = await fetch(`/api/widgets/layouts`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ layouts: widgetLayouts }),
      });
      if (!response.ok) throw new Error('Failed to save layout');
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['dashboard', dashboardId] });
      setEditMode(false);
      setLayoutsModified(false);
      setShowSuccessMessage(true);
      setTimeout(() => setShowSuccessMessage(false), 3000);
    },
  });

  // Generate layouts from widget configurations
  const [layouts, setLayouts] = useState<{ [key: string]: Layout[] }>({});

  // Initialize form values when dashboard loads
  useEffect(() => {
    if (dashboard) {
      setDashboardName(dashboard.name);
      if (dashboard.globalFilters?.dateRange) {
        setDateRangeStart(dashboard.globalFilters.dateRange.start || '');
        setDateRangeEnd(dashboard.globalFilters.dateRange.end || '');
      }
    }
  }, [dashboard]);

  useEffect(() => {
    if (!dashboard?.widgets) return;

    // Convert dashboard widgets to react-grid-layout layouts
    const generatedLayouts: { [key: string]: Layout[] } = {};

    Object.keys(BREAKPOINTS).forEach((breakpoint) => {
      generatedLayouts[breakpoint] = dashboard.widgets.map((widget, index) => {
        // Get layout for this breakpoint, or fall back to default
        const layout = widget.layouts?.find((l) => l.breakpoint === breakpoint);

        if (layout) {
          return {
            i: widget.id.toString(),
            x: layout.x,
            y: layout.y,
            w: layout.w,
            h: layout.h,
            minW: layout.minW || undefined,
            minH: layout.minH || undefined,
            maxW: layout.maxW || undefined,
            maxH: layout.maxH || undefined,
          };
        }

        // Get widget-type-specific size configuration
        const widgetSizeConfig = getWidgetSizeConfig(widget.widgetDefinition.widgetType);
        const cols = COLUMNS[breakpoint as keyof typeof COLUMNS];

        // Use widget type default width, but cap at available columns
        const defaultWidth = Math.min(widgetSizeConfig.default.w, cols);

        return {
          i: widget.id.toString(),
          x: (index * defaultWidth) % cols,
          y: Math.floor((index * defaultWidth) / cols) * widgetSizeConfig.default.h,
          w: defaultWidth,
          h: widgetSizeConfig.default.h,
          minW: widgetSizeConfig.min.w,
          minH: widgetSizeConfig.min.h,
          maxW: widgetSizeConfig.max.w,
          maxH: widgetSizeConfig.max.h,
        };
      });
    });

    setLayouts(generatedLayouts);
  }, [dashboard]);

  // Loading state
  if (isDashboardLoading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="flex flex-col items-center gap-3">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
          <p className="text-muted-foreground">Loading dashboard...</p>
        </div>
      </div>
    );
  }

  // Error state
  if (isDashboardError || !dashboard) {
    return (
      <div className="flex items-center justify-center h-screen">
        <div className="text-center max-w-md">
          <h2 className="text-2xl font-bold text-destructive mb-2">
            Failed to load dashboard
          </h2>
          <p className="text-muted-foreground">
            {dashboardError instanceof Error
              ? dashboardError.message
              : 'An unknown error occurred'}
          </p>
        </div>
      </div>
    );
  }

  return (
    <div data-testid="dashboard-viewer" className="p-6">
      {/* Success Message */}
      {showSuccessMessage && (
        <div
          className="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg flex items-center gap-2 z-50"
          data-testid="save-success-message"
        >
          <CheckCircle className="h-5 w-5" />
          Dashboard saved successfully
        </div>
      )}

      {/* Dashboard Header */}
      <div className="mb-6 flex items-center justify-between">
        <div>
          <h1 className="text-3xl font-bold text-foreground mb-2">
            {dashboard.name}
          </h1>
          {dashboard.description && (
            <p className="text-muted-foreground">{dashboard.description}</p>
          )}
        </div>

        <div className="flex gap-2">
          {/* User Story 4: Edit Layout Controls */}
          {!editMode ? (
            <Button
              variant="outline"
              onClick={() => setEditMode(true)}
              data-testid="edit-layout-button"
            >
              <Edit3 className="h-4 w-4 mr-2" />
              Edit Layout
            </Button>
          ) : (
            <>
              <Button
                variant="default"
                onClick={() => saveLayout.mutate(layouts)}
                disabled={!layoutsModified || saveLayout.isPending}
                data-testid="save-layout-button"
              >
                {saveLayout.isPending ? (
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <Save className="h-4 w-4 mr-2" />
                )}
                Save Layout
              </Button>
              <Button
                variant="outline"
                onClick={() => {
                  setEditMode(false);
                  setLayoutsModified(false);
                  // Reload layouts from dashboard
                  queryClient.invalidateQueries({ queryKey: ['dashboard', dashboardId] });
                }}
                data-testid="cancel-layout-button"
              >
                <X className="h-4 w-4 mr-2" />
                Cancel
              </Button>
            </>
          )}

          <Sheet open={showFilters} onOpenChange={setShowFilters}>
            <SheetTrigger asChild>
              <Button variant="outline" data-testid="global-filters-button">
                <Filter className="h-4 w-4 mr-2" />
                Filters
              </Button>
            </SheetTrigger>
            <SheetContent data-testid="global-filters-panel">
              <SheetHeader>
                <SheetTitle>Global Filters</SheetTitle>
                <SheetDescription>
                  Apply filters to all widgets on this dashboard
                </SheetDescription>
              </SheetHeader>
              <div className="space-y-4 mt-6">
                <div className="space-y-2">
                  <Label htmlFor="date-range-start">Date Range Start</Label>
                  <Input
                    id="date-range-start"
                    type="date"
                    data-testid="date-range-start"
                    value={dateRangeStart}
                    onChange={(e) => setDateRangeStart(e.target.value)}
                  />
                </div>
                <div className="space-y-2">
                  <Label htmlFor="date-range-end">Date Range End</Label>
                  <Input
                    id="date-range-end"
                    type="date"
                    data-testid="date-range-end"
                    value={dateRangeEnd}
                    onChange={(e) => setDateRangeEnd(e.target.value)}
                  />
                </div>
                <Button
                  className="w-full"
                  data-testid="apply-filters-button"
                  onClick={() => {
                    updateDashboard.mutate({
                      globalFilters: {
                        dateRange: {
                          start: dateRangeStart,
                          end: dateRangeEnd,
                        },
                      },
                    });
                    setShowFilters(false);
                  }}
                >
                  Apply Filters
                </Button>
              </div>
            </SheetContent>
          </Sheet>

          <Button onClick={() => setShowSaveDialog(true)} data-testid="save-dashboard-button">
            <Save className="h-4 w-4 mr-2" />
            Save
          </Button>
        </div>
      </div>

      {/* Widgets Grid */}
      {!dashboard.widgets || dashboard.widgets.length === 0 ? (
        <div className="flex items-center justify-center h-64 border-2 border-dashed border-muted rounded-lg">
          <p className="text-muted-foreground">
            No widgets configured for this dashboard
          </p>
        </div>
      ) : (
        <ResponsiveGridLayout
          className="layout"
          layouts={layouts}
          breakpoints={BREAKPOINTS}
          cols={COLUMNS}
          rowHeight={100}
          compactType="vertical"
          isDraggable={editMode} // User Story 4: Enable drag in edit mode
          isResizable={editMode} // User Story 4: Enable resize in edit mode
          margin={[16, 16]}
          containerPadding={[0, 0]}
          onLayoutChange={(currentLayout, allLayouts) => {
            if (editMode) {
              setLayouts(allLayouts);
              setLayoutsModified(true);
            }
          }}
        >
          {dashboard.widgets.map((widget) => (
            <div key={widget.id.toString()} className="h-full">
              <Widget widget={widget} />
            </div>
          ))}
        </ResponsiveGridLayout>
      )}

      {/* Save Dashboard Dialog */}
      <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>
        <DialogContent data-testid="save-dashboard-dialog">
          <DialogHeader>
            <DialogTitle>Save Dashboard</DialogTitle>
            <DialogDescription>
              Update the dashboard name and save your changes
            </DialogDescription>
          </DialogHeader>

          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label htmlFor="dashboard-name">Dashboard Name</Label>
              <Input
                id="dashboard-name"
                data-testid="dashboard-name-input"
                value={dashboardName}
                onChange={(e) => setDashboardName(e.target.value)}
                placeholder="Enter dashboard name"
              />
            </div>
          </div>

          <DialogFooter>
            <Button variant="outline" onClick={() => setShowSaveDialog(false)}>
              Cancel
            </Button>
            <Button
              onClick={() => updateDashboard.mutate({ name: dashboardName })}
              disabled={updateDashboard.isPending}
              data-testid="confirm-save-button"
            >
              {updateDashboard.isPending ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  Saving...
                </>
              ) : (
                <>
                  <Save className="mr-2 h-4 w-4" />
                  Save Changes
                </>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
