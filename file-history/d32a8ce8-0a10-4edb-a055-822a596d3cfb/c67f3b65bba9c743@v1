import { NextRequest, NextResponse } from 'next/server';
import { getToken } from 'next-auth/jwt';

interface RateLimitStore {
  [key: string]: {
    count: number;
    resetTime: number;
  };
}

const rateLimitStore: RateLimitStore = {};
const RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes
const MAX_REQUESTS = 100; // Max requests per window

function getRealClientIP(request: NextRequest): string {
  const forwardedFor = request.headers.get('x-forwarded-for');
  const realIP = request.headers.get('x-real-ip');
  const remoteAddr = request.headers.get('x-remote-addr');

  if (forwardedFor) {
    return forwardedFor.split(',')[0].trim();
  }

  return realIP || remoteAddr || request.ip || 'unknown';
}

function checkRateLimit(clientIP: string): { allowed: boolean; resetTime?: number } {
  const now = Date.now();
  const clientData = rateLimitStore[clientIP];

  if (!clientData || now > clientData.resetTime) {
    rateLimitStore[clientIP] = {
      count: 1,
      resetTime: now + RATE_LIMIT_WINDOW
    };
    return { allowed: true };
  }

  if (clientData.count >= MAX_REQUESTS) {
    return { allowed: false, resetTime: clientData.resetTime };
  }

  clientData.count++;
  return { allowed: true };
}

export async function middleware(request: NextRequest) {
  const { pathname } = request.nextUrl;

  // Skip rate limiting for static assets and Next.js internals
  if (
    pathname.startsWith('/_next/') ||
    pathname.startsWith('/api/_next/') ||
    pathname.includes('.') // Skip files with extensions (images, css, js, etc.)
  ) {
    return NextResponse.next();
  }

  // Apply rate limiting to API routes
  if (pathname.startsWith('/api/')) {
    const clientIP = getRealClientIP(request);
    const rateLimitResult = checkRateLimit(clientIP);

    if (!rateLimitResult.allowed) {
      const resetTime = rateLimitResult.resetTime;
      const retryAfter = resetTime ? Math.ceil((resetTime - Date.now()) / 1000) : 900; // Default 15 minutes

      return new NextResponse(
        JSON.stringify({
          error: 'Too many requests',
          message: 'Rate limit exceeded. Please try again later.',
          retryAfter
        }),
        {
          status: 429,
          headers: {
            'Content-Type': 'application/json',
            'Retry-After': retryAfter.toString(),
            'X-RateLimit-Limit': MAX_REQUESTS.toString(),
            'X-RateLimit-Remaining': '0',
            'X-RateLimit-Reset': rateLimitResult.resetTime?.toString() || '0'
          }
        }
      );
    }

    // Add rate limit headers to successful requests
    const response = NextResponse.next();
    const remaining = Math.max(0, MAX_REQUESTS - rateLimitStore[clientIP].count);

    response.headers.set('X-RateLimit-Limit', MAX_REQUESTS.toString());
    response.headers.set('X-RateLimit-Remaining', remaining.toString());
    response.headers.set('X-RateLimit-Reset', rateLimitStore[clientIP].resetTime.toString());

    return response;
  }

  // Protect authenticated routes
  if (pathname.startsWith('/dashboard') || pathname.startsWith('/admin')) {
    const token = await getToken({
      req: request,
      secret: process.env.NEXTAUTH_SECRET
    });

    if (!token) {
      const url = request.nextUrl.clone();
      url.pathname = '/signin';
      url.searchParams.set('callbackUrl', pathname);
      return NextResponse.redirect(url);
    }

    // Admin-only protection
    if (pathname.startsWith('/admin') && token.role !== 'admin') {
      return new NextResponse(
        JSON.stringify({ error: 'Access denied' }),
        {
          status: 403,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml).*)',
  ],
};